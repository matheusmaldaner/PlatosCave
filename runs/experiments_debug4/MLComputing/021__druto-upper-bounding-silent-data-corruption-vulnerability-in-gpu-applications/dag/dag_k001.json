{
  "nodes": [
    {
      "id": 0,
      "text": "It is possible to efficiently approximate and upper-bound the Silent Data Corruption (SDC) probability of a GPU kernel across inputs without performing expensive fault injections by using compiler-based analysis and targeted input search",
      "role": "Hypothesis",
      "parents": null,
      "children": [
        1,
        2,
        3
      ]
    },
    {
      "id": 1,
      "text": "Key empirical observation O1: the SDC probability of a GPU kernel across inputs can be approximated by the SDC probability of its dominant thread (the thread with the most dynamic instructions)",
      "role": "Claim",
      "parents": [
        0
      ],
      "children": [
        4
      ]
    },
    {
      "id": 2,
      "text": "Key empirical observation O2: the relative ranking of threads by dynamic instruction count approximates the relative ranking of threads by thread-level SDC probability across inputs",
      "role": "Claim",
      "parents": [
        0
      ],
      "children": [
        4
      ]
    },
    {
      "id": 3,
      "text": "Per-instruction SDC ranking stability observed for CPU programs does not hold for GPU kernels (average Spearman correlation ~0.59), so CPU-based techniques like PEPPA-X are ineffective on GPUs",
      "role": "Context",
      "parents": [
        0
      ],
      "children": [
        5
      ]
    },
    {
      "id": 4,
      "text": "Heuristic: by profiling dynamic instruction counts of threads and identifying dominant thread(s), one can derive a proxy ranking of kernel-level SDC probability across inputs without fault injections",
      "role": "Claim",
      "parents": [
        1,
        2
      ],
      "children": [
        6,
        7
      ]
    },
    {
      "id": 5,
      "text": "Limitation of prior work: PEPPA-X relies on stable per-instruction SDC rankings across inputs and thus becomes less effective for GPU programs due to GPU SIMT model and inter-thread data differences",
      "role": "Limitation",
      "parents": [
        3
      ],
      "children": null
    },
    {
      "id": 6,
      "text": "Method: DRUTO combines compiler-based static instrumentation, lightweight dynamic profiling of a representative dynamic kernel instance, a pruning strategy to avoid tracing all instances, and a GA-based fuzzing/search engine using a fitness score based on summed dynamic instructions of dominant threads",
      "role": "Method",
      "parents": [
        4
      ],
      "children": [
        8,
        9,
        10
      ]
    },
    {
      "id": 7,
      "text": "Fitness function used by DRUTO (no fault injection): fitness(input) = sum over n dominant threads of DF(d,j) where DF(d,j) is dynamic instruction count of thread j in chosen dynamic kernel instance d",
      "role": "Method",
      "parents": [
        4
      ],
      "children": null
    },
    {
      "id": 8,
      "text": "Pruning method: profile only one representative dynamic kernel instance (instead of all instances) because dynamic-instruction distributions across instances are similar, greatly reducing tracing overhead",
      "role": "Method",
      "parents": [
        6
      ],
      "children": [
        11
      ]
    },
    {
      "id": 9,
      "text": "Search engine: Genetic Algorithm (GA) guided by the non-FI fitness score iteratively generates inputs and uses profiling feedback to steer toward inputs approximating the kernel SDC upper bound",
      "role": "Method",
      "parents": [
        6
      ],
      "children": null
    },
    {
      "id": 10,
      "text": "Implementation detail: uses LLFI-GPU for post-search evaluation fault injections (1,000 random faults) to measure actual SDC probability of candidate SDC-bound inputs identified without FIs during search",
      "role": "Method",
      "parents": [
        6
      ],
      "children": null
    },
    {
      "id": 11,
      "text": "Result (accuracy): DRUTO finds inputs whose measured SDC probabilities are up to 74x higher than those found by baselines (PEPPA-X and random) given the same search time, and baselines cannot match DRUTO even with 5x more time",
      "role": "Result",
      "parents": [
        6,
        8
      ],
      "children": [
        12
      ]
    },
    {
      "id": 12,
      "text": "Result (efficiency): DRUTO evaluates inputs much faster than PEPPA-X (average per-input evaluation ~6 seconds for DRUTO vs ~260 seconds for PEPPA-X) because DRUTO avoids initial reduced FI campaigns",
      "role": "Result",
      "parents": [
        6
      ],
      "children": [
        13
      ]
    },
    {
      "id": 13,
      "text": "Result (pruning effectiveness): pruning yields large computation speedups (average non-pruned slowdown ~80.96x) and causes negligible impact on accuracy (average bounding difference ~1.28%), validating representative-instance profiling",
      "role": "Result",
      "parents": [
        8
      ],
      "children": null
    },
    {
      "id": 14,
      "text": "Case study 1 (conclusion): using DRUTO-generated SDC-bound inputs to stress-test selective instruction duplication (SID) shows SID protection coverage drops substantially (expected coverage 85.6% with reference input vs actual 59.9% with SDC-bound inputs), revealing underestimated vulnerabilities",
      "role": "Conclusion",
      "parents": [
        11
      ],
      "children": null
    },
    {
      "id": 15,
      "text": "Case study 2 (comparison): replacing DRUTO fitness with GPU-Trident model during search shows GPU-Trident is less effective at upper-bounding SDC across inputs and is slower (about 3x DRUTO per-input time) because GPU-Trident focuses on single-input modeling and is insensitive to input diversity",
      "role": "Result",
      "parents": [
        6,
        11
      ],
      "children": null
    }
  ]
}