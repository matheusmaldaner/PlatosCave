{
  "nodes": [
    {
      "id": 0,
      "text": "It is possible to efficiently approximate and upper-bound the SDC (silent data corruption) probability of a GPU kernel across program inputs by searching for SDC-bound inputs using kernel-level characteristics of a small set of representative threads instead of expensive fault injections",
      "role": "Hypothesis",
      "parents": null,
      "children": [
        1,
        2,
        3,
        4
      ]
    },
    {
      "id": 1,
      "text": "Observation O1: The SDC probability of a GPU kernel can be approximated by the SDC probability of its dominant thread (the thread with most dynamic instructions); dominant-thread SDC ranking strongly correlates with kernel-level SDC ranking across inputs (average Spearman ~0.81)",
      "role": "Evidence",
      "parents": [
        0
      ],
      "children": [
        5,
        6
      ]
    },
    {
      "id": 2,
      "text": "Observation O2: The relative ranking of threads by their dynamic instruction counts can approximate the relative ranking of thread-level SDC probabilities across inputs (average Spearman ~0.73), i.e., dynamic instruction count is a lightweight proxy for thread SDC proneness",
      "role": "Evidence",
      "parents": [
        0
      ],
      "children": [
        5,
        6
      ]
    },
    {
      "id": 3,
      "text": "Limitation of prior work: Per-instruction SDC ranking stability across inputs observed for CPU programs (PEPPA-X) does not hold for GPU kernels (average Spearman ~0.59), so CPU-based heuristics are ineffective for GPUs",
      "role": "Context",
      "parents": [
        0
      ],
      "children": [
        6
      ]
    },
    {
      "id": 4,
      "text": "Design claim: Combining thread-level dynamic-instruction profiling, selection of dominant threads, and search-based input fuzzing (e.g., genetic algorithm) yields an automated technique to find inputs that approach the upper bound of kernel SDC probability without conducting per-input fault injections",
      "role": "Claim",
      "parents": [
        0
      ],
      "children": [
        7,
        8,
        9
      ]
    },
    {
      "id": 5,
      "text": "Heuristic: By profiling the number of dynamic instructions of the dominant thread of a kernel for a given input, one can approximate the input's rank in kernel SDC probability across inputs and thus use that rank as a fitness signal for input search",
      "role": "Claim",
      "parents": [
        1,
        2
      ],
      "children": [
        7
      ]
    },
    {
      "id": 6,
      "text": "Empirical observation: Kernel SDC probability varies widely across inputs for many GPU kernels (examples: Backprop kernel range 0.10%–77.70; some kernels have narrow ranges), so reference inputs can be over-optimistic for resilience evaluation",
      "role": "Evidence",
      "parents": [
        3
      ],
      "children": [
        4,
        12
      ]
    },
    {
      "id": 7,
      "text": "Method: DRUTO implements a compiler-based workflow that instruments GPU kernels (LLVM IR), profiles per-thread dynamic instruction counts for a representative dynamic kernel instance, and uses a genetic algorithm fuzzing engine guided by a fitness function to search inputs",
      "role": "Method",
      "parents": [
        4,
        5
      ],
      "children": [
        8,
        9,
        10
      ]
    },
    {
      "id": 8,
      "text": "Method detail - pruning: DRUTO prunes dynamic tracing by profiling only one representative dynamic kernel instance (kernel trace pruning) because dynamic instances of a static kernel show similar instruction-count distributions, reducing runtime overhead",
      "role": "Method",
      "parents": [
        7
      ],
      "children": [
        11
      ]
    },
    {
      "id": 9,
      "text": "Method detail - fitness: DRUTO assigns an input fitness equal to the sum of dynamic instruction counts of the n dominant threads in a chosen dynamic instance (fitness = sum_j DF(d,j)), requiring no fault injections during search",
      "role": "Method",
      "parents": [
        7
      ],
      "children": [
        10
      ]
    },
    {
      "id": 10,
      "text": "Result: DRUTO finds SDC-bound inputs that produce much higher measured kernel SDC probabilities than baselines; given equal time budget DRUTO outperforms PEPPA-X and random search by up to 74x in upper-bounding SDC probability and baselines cannot match DRUTO even with 5x more time",
      "role": "Result",
      "parents": [
        7,
        9
      ],
      "children": [
        12
      ]
    },
    {
      "id": 11,
      "text": "Result - efficiency: Kernel trace pruning yields large speedups (non-pruned DRUTO shows average 80.96x slowdown compared to pruned) and pruning changes bounded SDC probability negligibly (average difference ~1.28%), validating pruning effectiveness",
      "role": "Result",
      "parents": [
        8
      ],
      "children": [
        10
      ]
    },
    {
      "id": 12,
      "text": "Case study conclusion: Using DRUTO-generated SDC-bound inputs reveals deficiencies in selective instruction duplication (SID) protections—expected SDC coverage measured with reference inputs (average 85.58%) drops to much lower actual coverage under DRUTO inputs (average 59.94%)—showing protections can be under-estimated if only reference inputs used",
      "role": "Conclusion",
      "parents": [
        6,
        10
      ],
      "children": [
        13
      ]
    },
    {
      "id": 13,
      "text": "Comparison evidence: Replacing DRUTO's fitness with GPU-Trident predictions yields inferior search results; GPU-Trident is less sensitive to diverse inputs and is slower per-input (about 3x slower than DRUTO), so modeling-for-single-input approaches cannot substitute DRUTO for upper-bounding across inputs",
      "role": "Evidence",
      "parents": [
        10
      ],
      "children": [
        14
      ]
    },
    {
      "id": 14,
      "text": "Conclusion: DRUTO is an automated, effective, and efficient technique to incrementally estimate an upper bound of GPU kernel SDC probability across inputs without per-input fault injection, enabling more conservative and practical resilience evaluation",
      "role": "Conclusion",
      "parents": [
        10,
        11,
        12,
        13
      ],
      "children": null
    }
  ]
}