{
  "nodes": [
    {
      "id": 0,
      "text": "A compiler-based search technique can efficiently and automatically find program inputs that approximate the upper bound of GPU kernel silent data corruption (SDC) probability without performing costly fault injections during the search",
      "role": "Hypothesis",
      "parents": null,
      "children": [
        1,
        2,
        3
      ]
    },
    {
      "id": 1,
      "text": "Observation O1: The SDC probability of a GPU kernel can be approximated by the SDC probability of its dominant thread (the thread with the most dynamic instructions)",
      "role": "Claim",
      "parents": [
        0
      ],
      "children": [
        4,
        5
      ]
    },
    {
      "id": 2,
      "text": "Observation O2: The relative ranking of threads by dynamic instruction counts approximates the relative ranking of threads by thread-level SDC probability across inputs",
      "role": "Claim",
      "parents": [
        0
      ],
      "children": [
        4,
        5
      ]
    },
    {
      "id": 3,
      "text": "Per-instruction SDC ranking stability across inputs observed in CPU programs (PEPPA-X) does not hold for GPU kernels, so CPU-based heuristics are ineffective for bounding GPU SDCs",
      "role": "Claim",
      "parents": [
        0
      ],
      "children": [
        6
      ]
    },
    {
      "id": 4,
      "text": "Heuristic: Profiling dynamic instruction counts of dominant thread(s) per kernel provides a cheap proxy (no fault injections) to estimate and rank kernel SDC probability across inputs",
      "role": "Claim",
      "parents": [
        1,
        2
      ],
      "children": [
        7
      ]
    },
    {
      "id": 5,
      "text": "Method: Use genetic algorithm based fuzzing to generate candidate inputs and assign each input a fitness score equal to the sum of dynamic instruction counts of n dominant threads in a chosen dynamic kernel instance",
      "role": "Method",
      "parents": [
        4
      ],
      "children": [
        8
      ]
    },
    {
      "id": 6,
      "text": "Limitation of prior work: PEPPA-X requires per-instruction SDC ranking stability across inputs and reduced initial fault injections, assumptions that fail for GPU programming model and SIMD/thread divergence",
      "role": "Claim",
      "parents": [
        3
      ],
      "children": [
        8
      ]
    },
    {
      "id": 7,
      "text": "Implementation (DRUTO): compiler instrumentation to profile per-thread dynamic instruction counts, kernel-trace pruning to profile a representative dynamic kernel instance, GA search loop using the derived fitness function, and no FI during search",
      "role": "Method",
      "parents": [
        5
      ],
      "children": [
        9,
        10
      ]
    },
    {
      "id": 8,
      "text": "Evaluation methodology: Compare DRUTO to PEPPA-X (adapted to GPUs) and RANDOM, measure bounded SDC probability by injecting 1000 random faults into the final inputs produced by each technique, and measure search time and per-input evaluation time",
      "role": "Method",
      "parents": [
        5,
        6
      ],
      "children": [
        9,
        10,
        11
      ]
    },
    {
      "id": 9,
      "text": "Result: Across 14 GPU kernels, DRUTO found inputs that produced upper-bound SDC probabilities up to 74x higher than baselines given equal search time; baselines still failed to match DRUTO even with 5x longer time",
      "role": "Result",
      "parents": [
        7,
        8
      ],
      "children": [
        12
      ]
    },
    {
      "id": 10,
      "text": "Result: DRUTO is much more efficient per explored input (average ~6 seconds) than PEPPA-X (average ~260 seconds) because DRUTO avoids initial FI campaigns and uses lightweight profiling",
      "role": "Result",
      "parents": [
        7,
        8
      ],
      "children": [
        12
      ]
    },
    {
      "id": 11,
      "text": "Result: Kernel-trace pruning (profiling one representative dynamic kernel instance) reduces runtime overhead dramatically (non-pruned slowdown average 80.96x) while changing bounded SDC results negligibly (average difference 1.28%)",
      "role": "Result",
      "parents": [
        7,
        8
      ],
      "children": [
        12
      ]
    },
    {
      "id": 12,
      "text": "Case study 1 (Claim + Evidence): Using DRUTO-generated SDC-bound inputs to stress-test selective instruction duplication (SID) reveals that expected SDC coverage (measured with reference inputs) overestimates protection effectiveness; average expected coverage 85.6% vs actual 59.9% under DRUTO inputs",
      "role": "Evidence",
      "parents": [
        9,
        10
      ],
      "children": [
        13
      ]
    },
    {
      "id": 13,
      "text": "Case study 2 (Claim + Evidence): Replacing DRUTO fitness with GPU-Trident predictions shows GPU-Trident is less effective across diverse inputs and slower (~15s per input), demonstrating modeling approaches focused on single inputs cannot replace DRUTO heuristics for upper-bounding SDCs",
      "role": "Evidence",
      "parents": [
        9,
        10
      ],
      "children": [
        14
      ]
    },
    {
      "id": 14,
      "text": "Conclusion: DRUTO is an automated, efficient, and effective tool to upper-bound GPU kernel SDC probability across inputs without FIs during search; it outperforms PEPPA-X, RANDOM, and modeling baselines and exposes deficiencies in input-insensitive protections",
      "role": "Conclusion",
      "parents": [
        9,
        10,
        11,
        12,
        13
      ],
      "children": null
    }
  ]
}